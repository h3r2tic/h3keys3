use winapi::shared::minwindef::*;
use winapi::shared::windef::{HWND, HBRUSH, HICON, HCURSOR, HMENU, POINT, RECT};
use winapi::shared::ntdef::{LPCSTR};
use winapi::um::winuser;
use kernel32::{GetModuleHandleA};

use winrt::*;
use winrt::windows::data::xml::dom::*;
use winrt::windows::ui::notifications::*;

pub const ESCAPE : char = winuser::VK_ESCAPE as u8 as char;
pub const SEMICOLON : char = winuser::VK_OEM_1 as u8 as char;
pub const TILDE : char = winuser::VK_OEM_3 as u8 as char;
pub const UK_TILDE : char = winuser::VK_OEM_5 as u8 as char;
pub const ALT_GR : char = winuser::VK_RMENU as u8 as char;
pub const RIGHTCTRL : char = winuser::VK_RCONTROL as u8 as char;
pub const LEFTCTRL : char = winuser::VK_LCONTROL as u8 as char;
pub const CTRL : char = winuser::VK_CONTROL as u8 as char;
pub const LEFTALT : char = winuser::VK_LMENU as u8 as char;
pub const ALT : char = winuser::VK_MENU as u8 as char;
pub const BACKSPACE : char = winuser::VK_BACK as u8 as char;
pub const COMMA : char = winuser::VK_OEM_COMMA as u8 as char;
pub const PERIOD : char = winuser::VK_OEM_PERIOD as u8 as char;
pub const FWD_SLASH : char = winuser::VK_OEM_2 as u8 as char;
pub const MINUS : char = winuser::VK_OEM_MINUS as u8 as char;
pub const PLUS : char = winuser::VK_OEM_PLUS as u8 as char;

pub const RETURN : char = winuser::VK_RETURN as u8 as char;
pub const DELETE : char = winuser::VK_DELETE as u8 as char;
pub const PGUP : char = winuser::VK_PRIOR as u8 as char;
pub const PGDOWN : char = winuser::VK_NEXT as u8 as char;
				
pub const SHIFT : char = winuser::VK_SHIFT as u8 as char;
pub const CAPS_LOCK : char = winuser::VK_CAPITAL as u8 as char;
pub const LWIN : char = winuser::VK_LWIN as u8 as char;
pub const OEM_102 : char = winuser::VK_OEM_102 as u8 as char;
pub const OEM_5 : char = winuser::VK_OEM_5 as u8 as char;
pub const LSQUARE : char = winuser::VK_OEM_4 as u8 as char;
pub const RSQUARE : char = winuser::VK_OEM_6 as u8 as char;
pub const APPS : char = winuser::VK_APPS as u8 as char;
pub const SPACE : char = winuser::VK_SPACE as u8 as char;

pub const F1 : char = winuser::VK_F1 as u8 as char;
pub const F2 : char = winuser::VK_F2 as u8 as char;
pub const F3 : char = winuser::VK_F3 as u8 as char;
pub const F4 : char = winuser::VK_F4 as u8 as char;
pub const F5 : char = winuser::VK_F5 as u8 as char;
pub const F6 : char = winuser::VK_F6 as u8 as char;
pub const F7 : char = winuser::VK_F7 as u8 as char;
pub const F8 : char = winuser::VK_F8 as u8 as char;
pub const F9 : char = winuser::VK_F9 as u8 as char;
pub const F10 : char = winuser::VK_F10 as u8 as char;
pub const F11 : char = winuser::VK_F11 as u8 as char;
pub const F12 : char = winuser::VK_F12 as u8 as char;

pub const LEFT : char = winuser::VK_LEFT as u8 as char;
pub const RIGHT : char = winuser::VK_RIGHT as u8 as char;
pub const HOME : char = winuser::VK_HOME as u8 as char;
pub const END : char = winuser::VK_END as u8 as char;
pub const BACK : char = winuser::VK_BACK as u8 as char;

// Used to distinguish input events generated by this app, and avoid recursion in input generation
const H3KEYS_MAGIC : usize = 666;

fn get_window_under_cursor(cursor_pos: (i32, i32)) -> HWND {
	unsafe {
		let w = winuser::WindowFromPoint( POINT { x: cursor_pos.0, y: cursor_pos.1 } );
		let w = winuser::GetAncestor(w, 2 /* GA_ROOT */);

		let win_name = [0u8; 256];
		winuser::GetWindowTextA(w, mem::transmute(&win_name), 256);

		let nul_pos = win_name.iter().position(|&x| x == 0u8);
		let nul_pos = match nul_pos {
			Some(pos) => pos,
			None => return ptr::null_mut(),
		};

		let win_name = str::from_utf8(&win_name[..nul_pos]);

		match win_name {
			// Let's not move the Desktop...
			Ok("Program Manager") => return ptr::null_mut(),
			Ok(name) => name,
			Err(_) => return ptr::null_mut(),
		};

		w
	}
}

fn get_window_rect(hwnd: HWND) -> RECT {
	let mut rect = RECT { left: 0, top: 0, right: 0, bottom: 0 };
	unsafe { winuser::GetWindowRect(hwnd, &mut rect); }
	rect
}

struct ScrollEmuState
{
	scroll_emu_on: bool,
	scroll_emu_from: (i32, i32),
	scroll_emu_acc: (f32, f32),
}

impl ScrollEmuState
{
	fn new() -> ScrollEmuState {
		ScrollEmuState {
			scroll_emu_on: false,
			scroll_emu_from: (0, 0),
			scroll_emu_acc: (0f32, 0f32),
		}
	}

	fn mouse_hook(&mut self, wparam: WPARAM, mouse_data : winuser::MSLLHOOKSTRUCT) -> LRESULT
	{
		if winuser::WM_MBUTTONDOWN == wparam as u32 {
			self.scroll_emu_from = (mouse_data.pt.x, mouse_data.pt.y);
			self.scroll_emu_acc = (0f32, 0f32);
			self.scroll_emu_on = true;
			return 1;
		}

		if winuser::WM_MBUTTONUP == wparam as u32 {
			self.scroll_emu_on = false;
			return 1;
		}

		if winuser::WM_MOUSEMOVE == wparam as u32 && self.scroll_emu_on {
			let hscroll = (mouse_data.pt.x - self.scroll_emu_from.0) as f32;
			let vscroll = (self.scroll_emu_from.1 - mouse_data.pt.y) as f32;

			// Dead zone
			//let hscroll = if hscroll * hscroll > 1f32 { hscroll } else { 0f32 };
			//let vscroll = if vscroll * vscroll > 1f32 { vscroll } else { 0f32 };

			// Curve
			let hscroll = hscroll.signum() * hscroll.abs().powf(1.5f32);
			let vscroll = vscroll.signum() * vscroll.abs().powf(1.5f32);

			// Blend
			let t = 0.3f32;
			self.scroll_emu_acc.0 = self.scroll_emu_acc.0 * (1.0f32 - t) + hscroll * t;
			self.scroll_emu_acc.1 = self.scroll_emu_acc.1 * (1.0f32 - t) + vscroll * t;

			return 1;
		}

		0
	}

	fn emulate_scroll(&mut self) -> Box<Fn()>
	{
		if self.scroll_emu_on {
			let decay = 0.92f32;
			self.scroll_emu_acc = (self.scroll_emu_acc.0 * decay, self.scroll_emu_acc.1 * decay);
		}

		let scroll_from = self.scroll_emu_from;
		let scroll_acc = if self.scroll_emu_on { self.scroll_emu_acc } else { (0f32, 0f32) };

		// Defer winapi usage so that we can bring it outside of the mutex in the calling code
		Box::new(move || {
			if scroll_acc.0 as i32 != 0 {
				unsafe {
					winuser::mouse_event(
						winuser::MOUSEEVENTF_HWHEEL,
						scroll_from.0 as u32,
						scroll_from.1 as u32,
						scroll_acc.0 as i32 as u32,
						H3KEYS_MAGIC);
				}
			}

			if scroll_acc.1 as i32 != 0 {
				unsafe {
					winuser::mouse_event(
						winuser::MOUSEEVENTF_WHEEL,
						scroll_from.0 as u32,
						scroll_from.1 as u32,
						scroll_acc.1 as i32 as u32,
						H3KEYS_MAGIC);
				}
			}
		})
	}
}

pub struct OsState {
	window_move_hwnd: HWND,
	mouse_move_from: (i32, i32),
	window_move_from: (i32, i32),

	window_resize_hwnd: HWND,
	mouse_resize_from: (i32, i32),
	window_resize_from: (i32, i32),

	scroll_emu_state: Arc<Mutex<ScrollEmuState>>,
}

pub fn send_key(key: u8, down: bool) {
	unsafe {
		let mut input = winuser::INPUT {
			type_: winuser::INPUT_KEYBOARD,
			u: mem::uninitialized()
		};

		*input.u.ki_mut() = winuser::KEYBDINPUT {
			wVk: key as u16,
			wScan: winuser::MapVirtualKeyA(key as u32, winuser::MAPVK_VK_TO_VSC) as u16,
			dwFlags: if down {0} else {winuser::KEYEVENTF_KEYUP},
			time: 0,
			dwExtraInfo: H3KEYS_MAGIC,
		};

        winuser::SendInput(1, &mut input, mem::size_of::<winuser::INPUT>() as i32);
	}

	//unsafe { winuser::keybd_event(key, 0, if down {0} else {winuser::KEYEVENTF_KEYUP}, H3KEYS_MAGIC); }
}

unsafe extern "system" fn global_key_hook(code: i32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
	if let Some(hook_state) = HOOK_STATE.as_mut() {
		hook_state.win_key_hook(code, wparam, lparam)
	} else {
		0
	}
}

unsafe extern "system" fn global_mouse_hook(code: i32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
	if let Some(hook_state) = HOOK_STATE.as_mut() {
		hook_state.mouse_hook(code, wparam, lparam)
	} else {
		0
	}

}

pub unsafe extern "system" fn win_proc(
	h_wnd: HWND, msg: UINT, w_param: WPARAM, l_param: LPARAM) -> LRESULT {
    if msg == winuser::WM_DESTROY {
        winuser::PostQuitMessage(0);
    }
    return winuser::DefWindowProcW(h_wnd, msg, w_param, l_param);
}

thread_local! {
	static TOAST_NOTIFIER : RefCell<winrt::ComPtr<ToastNotifier>> =
		RefCell::new(ToastNotificationManager::create_toast_notifier_with_id(
			// Use PowerShell's App ID to circumvent the need to register one.
			&FastHString::new("{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}\\WindowsPowerShell\\v1.0\\powershell.exe")
		).unwrap());

	static PREVIOUS_TOAST: RefCell<Option<ComPtr<ToastNotification>>> = RefCell::new(None);
}

fn toast_notification(content: &str)
{
	TOAST_NOTIFIER.with(|toast_notifier| {
		let toast_notifier = &*toast_notifier.borrow();

		PREVIOUS_TOAST.with(|prev_toast| {
			let prev_toast = &mut *prev_toast.borrow_mut();

			// If there's any previous toast, hide it right away.
			if let &mut Some(ref toast) = prev_toast {
				unsafe { toast_notifier.hide(toast).ok(); }
				*prev_toast = None;
			}

			unsafe {
			    // Get a toast XML template
			    let toast_xml = ToastNotificationManager::get_template_content(ToastTemplateType::ToastText02).unwrap();

			    // Fill in the text elements
			    let toast_text_elements = toast_xml.get_elements_by_tag_name(&FastHString::new("text")).unwrap();
			    
			    toast_text_elements.item(0).unwrap().append_child(&*toast_xml.create_text_node(&FastHString::new("h3keys")).unwrap().query_interface::<IXmlNode>().unwrap()).unwrap();
			    toast_text_elements.item(1).unwrap().append_child(&*toast_xml.create_text_node(&FastHString::new(content)).unwrap().query_interface::<IXmlNode>().unwrap()).unwrap();

			    // Create the toast and attach event listeners
			    let toast = ToastNotification::create_toast_notification(&*toast_xml).unwrap();

			    // Show the toast
				(*toast_notifier).show(&*toast).unwrap();

				// Save it for next time, so we can hide it quickly
				*prev_toast = Some(toast);
			}
		});
	});
}

fn run()
{
	unsafe {
		HOOK_STATE = Some(InputHookState::new());
		kernel32::SetThreadPriority(kernel32::GetCurrentThread(), 1 /* THREAD_PRIORITY_ABOVE_NORMAL */);
	}

	{
		let scroll_state = unsafe { HOOK_STATE.as_mut().unwrap().scroll_emu_state.clone() };

		thread::spawn(move || {
			loop {
				let run_scroll_actions = scroll_state.lock().unwrap().emulate_scroll();
				run_scroll_actions();
				thread::sleep(time::Duration::from_millis(10));
			}
		});
	}

	unsafe {
		winuser::SetWindowsHookExA(
			winuser::WH_KEYBOARD_LL,
			Some(global_key_hook),
			GetModuleHandleA(ptr::null()) as HINSTANCE,
			0);

		winuser::SetWindowsHookExA(
			winuser::WH_MOUSE_LL,
			Some(global_mouse_hook),
			GetModuleHandleA(ptr::null()) as HINSTANCE,
			0);
	}

	let class_name = "h3keys3";
	let wnd_class = winuser::WNDCLASSA {
		style: 0,
		lpfnWndProc: Some(win_proc), 
		cbClsExtra: 0,
		cbWndExtra: 0,
		hInstance: 0 as HINSTANCE,
		hIcon: 0 as HICON,
		hCursor: 0 as HCURSOR,
		hbrBackground: 16 as HBRUSH,
		lpszMenuName: 0 as LPCSTR,
		lpszClassName: class_name.as_ptr() as *const i8,
	};

    if 0 == unsafe { winuser::RegisterClassA(&wnd_class) } {
    	panic!("RegisterClassA failed.");
    }

	let hwnd = unsafe {
		winuser::CreateWindowExA(
			0,
			class_name.as_ptr() as *const i8,
			class_name.as_ptr() as *const i8,
			0,
			winuser::CW_USEDEFAULT,
			winuser::CW_USEDEFAULT,
			320, 240,
			winuser::GetDesktopWindow(),
			0 as HMENU,
			0 as HINSTANCE,
			std::ptr::null_mut())
	};

    let mut msg = winuser::MSG {
        hwnd : 0 as HWND,
        message : 0 as UINT,
        wParam : 0 as WPARAM,
        lParam : 0 as LPARAM,
        time : 0 as DWORD,
        pt : POINT { x: 0, y: 0, },
    };

    loop {
	    unsafe {
	        let pm = winuser::GetMessageW(&mut msg, hwnd, 0, 0);
	        if pm > 0 {
	            winuser::TranslateMessage(&mut msg);
	            winuser::DispatchMessageW(&mut msg);
	        }
	    }
	}
}

pub fn kill_top_window_process() {
	unsafe {
		let top_window = winuser::GetForegroundWindow();
		let mut pid : DWORD = 0;
		winuser::GetWindowThreadProcessId(top_window, &mut pid);

		let h = kernel32::OpenProcess(winapi::um::winnt::PROCESS_ALL_ACCESS, 0, pid);
		if h != ptr::null_mut() {
			kernel32::TerminateProcess(h, 0);
		}
	}
}

pub fn lock_workstation() {
	unsafe { winuser::LockWorkStation(); }
}

